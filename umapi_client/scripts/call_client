#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
CLI for UMAPI client.
"""

from umapi_client import config, logging, TIMESTAMP_FORMAT, RESPONSE_FORMAT
from umapi_client.client import UMAPIClient
from re import search, sub

from multiprocessing import Process
from rafutils import enum
import json
import argparse
from datetime import datetime
from sys import exit
from time import sleep

__author__ = "ryan faulkner"
__email__ = 'rfaulkner@wikimedia.org'
__date__ = "2013-03-27"
__license__ = "GPL (version 2 or later)"


# Enum for response types
RESPONSE_TYPES = enum('JSON', 'JOB_RUNNING', 'JOB_STARTED', 'UNKNOWN')


def parseargs():
    """
        Parse command line arguments. Returns *args*, the list of arguments
        left over after processing.
    """

    parser = argparse.ArgumentParser(
        description="Requests a url from the Wimedia user metrics API.",
        epilog="",
        conflict_handler="resolve",
        usage="umapi_client [url]"
    )

    parser.allow_interspersed_args = False

    # Global options.
    parser.add_argument('url')
    parser.add_argument('-s',
                        '--save_file',
                        action='store_true',
                        help='store response on file.')
    parser.add_argument('-t',
                        '--timestamp',
                        action='store_true',
                        help='timestamp the filename.')
    parser.add_argument('-p',
                        '--print_res',
                        action='store_true',
                        help='prints response.')
    parser.add_argument('-i',
                        '--timeout',
                        type=int,
                        default=10,
                        help='Total timeout.')
    parser.add_argument('-w',
                        '--wait',
                        type=int,
                        default=1,
                        help='Wait between requests.')

    args = parser.parse_args()
    return args


def format_filename(args):
    """ Formats the file name optionally emitted byt the client """

    # Parse url path
    bits = args.url.split('/')

    try:
        suffix = 'Q'.join(bits[2].split('?'))
        suffix = '_'.join(suffix.split('&'))
        suffix = '-'.join(suffix.split('='))
        suffix = bits[1] + '_' + suffix + '_'
    except KeyError:
        logging.error(__name__ + ' :: Couldn\'t parse url for filename.')
        suffix = ''

    filename = 'umapi_client_' + suffix
    if args.timestamp:
        filename += datetime.now().strftime(TIMESTAMP_FORMAT)[:8]
    return filename + RESPONSE_FORMAT


def response_type(response):
    """ Determine the type of response. """

    if search(r'</html>', response) and search(r'running', response):
        return RESPONSE_TYPES.JOB_RUNNING
    elif search(r'</html>', response) and search(r'Processing', response):
        return RESPONSE_TYPES.JOB_STARTED
    elif search(r'</html>', response):
        return RESPONSE_TYPES.UNKNOWN
    else:

        return RESPONSE_TYPES.JSON


def request_handler(request, args, timeout, wait_time):
    """ Parses and tracks UMAPI request. """

    response_str = None
    host = config.URL_ROOT + str(args.url)
    wait_count = 0

    # Process loop
    while 1:

        # Make request
        try:
            response = request.get_request(host)
        except Exception as e:
            logging.error(__name__ + ' :: Could not get response - {0}.'.
                format(e.message))
            return

        rt = response_type(response)
        if rt == RESPONSE_TYPES.JSON:
            response_str = str(json.loads(response))
            break
        elif rt == RESPONSE_TYPES.JOB_STARTED:

            # Filter "refresh" query variable from url if it exists
            # This prevents jobs from constantly being refreshed
            host = sub(r'refresh&', r'', host)
            host = sub(r'&refresh', r'', host)

            logging.debug(__name__ + ' :: Job initiated at {0}.'.format(host))
        elif rt == RESPONSE_TYPES.JOB_RUNNING:
            logging.debug(__name__ + ' :: Job running at {0}.'.format(host))
        elif rt == RESPONSE_TYPES.UNKNOWN:
            logging.error(__name__ + ' :: Unknown response from API.')

        wait_count += wait_time
        sleep(wait_time)

        if wait_count > timeout:
            logging.debug(__name__ + ' :: Exceeded timeout.')
            return
        else:
            logging.debug(__name__ + ' :: Time wait = {0}. Timeout = {1}'.
                format(wait_count, timeout))

    # Handle response - save? print to stdout?

    if args.save_file:
        filename = format_filename(args)

        logging.debug(__name__ + ' :: Writing response to file: {0}'.
        format(filename))

        with open(config.JSON_DIR + filename, 'wb') as f:
            f.write(response_str)

    if args.print_res:
        print str(response_str)


def main():

    # e.g. url = 'cohorts/ryan_test_2/bytes_added'
    args = parseargs()

    # Initialize a requester object
    logging.debug(__name__ + ' :: Attempting to create cookie jar, '
                             'logging in ..')
    umapi_req = UMAPIClient(config.UMAPI_USER,
                            config.UMAPI_PASS)

    # TODO Validate the url

    if args.wait < config.MIN_WAIT_REQ:
        logging.error(__name__ + ' :: Wait time to small. '
                                  'Must be at least {0}'.format(
            config.MIN_WAIT_REQ))
        return

    # Call the request handler
    p = Process(target=request_handler, args=[umapi_req, args, args.timeout, args.wait])
    p.start()
    p.join()

    logging.debug(__name__ + ' :: Shutting down umapi client.')


def cli():
    exit(main())


if __name__ == '__main__':
    cli()
